import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { authService } from '../../services/authService'; // Adjust path as needed

// --- Async Thunks ---

// Login Thunk
export const login = createAsyncThunk(
  'auth/login',
  async (credentials, { rejectWithValue }) => {
    try {
      const data = await authService.login(credentials);
      return data; // This will be the action.payload in the fulfilled case
    } catch (error) {
      // Use rejectWithValue to pass the error message as payload
      return rejectWithValue(error.message);
    }
  }
);

// Register Thunk
export const register = createAsyncThunk(
  'auth/register',
  async (userData, { rejectWithValue }) => {
    try {
      const data = await authService.register(userData);
      // Registration returns a message, not user data directly
      return data.message; // Return the success message
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Logout is synchronous, handled by a simple reducer
export const logout = createAsyncThunk('auth/logout', async () => {
  // No backend call needed for simple logout, just clear local state
  localStorage.removeItem('userInfo');
});

// --- Slice Definition ---

// Attempt to load user info from localStorage (e.g., after a page refresh)
const userInfoFromStorage = localStorage.getItem('userInfo')
  ? JSON.parse(localStorage.getItem('userInfo'))
  : null;

const initialState = {
  userInfo: userInfoFromStorage, // User object + token upon login
  loading: false,
  error: null,
  redirectPath: null
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // Reducer for when login/register request starts
    userAuthRequest: (state) => {
      state.loading = true;
      state.error = null;
    },
    // Reducer for successful login/register
    userAuthSuccess: (state, action) => {
      state.userInfo = action.payload;
      state.loading = false;
      state.error = null;
      // Determine redirect path based on user role
      state.redirectPath = action.payload.role === 'Admin' 
        ? '/admin/dashboard'
        : action.payload.role === 'ExamManager'
          ? '/exam-manager/dashboard'
          : '/dashboard';
      // Save user info to localStorage
      localStorage.setItem('userInfo', JSON.stringify(action.payload));
    },
    // Reducer for failed login/register
    userAuthFail: (state, action) => {
      state.loading = false;
      state.error = action.payload;
      state.userInfo = null; // Clear user info on fail
      localStorage.removeItem('userInfo'); // Clear localStorage on fail
    },
    // Reducer for logout (synchronous, but can be handled here too)
    userLogout: (state) => {
      state.loading = false;
      state.error = null;
      state.userInfo = null;
      localStorage.removeItem('userInfo');
    },
    // We will use extraReducers to handle the states of async thunks
  },
  extraReducers: (builder) => {
    builder
      // Login cases
      .addCase(login.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.userInfo = action.payload; // Payload is user data + token
        state.error = null;
        localStorage.setItem('userInfo', JSON.stringify(action.payload));
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload; // Payload is the error message
        state.userInfo = null;
        localStorage.removeItem('userInfo');
      })
      // Register cases
      .addCase(register.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state) => {
        state.loading = false;
        // Registration successful, but user is not logged in yet.
        // We might set a success message here if needed, or handle in component.
        state.error = null;
        // Don't set userInfo or localStorage here, user needs to verify/login
      })
      .addCase(register.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload; // Payload is the error message
      })
      // Logout case (handled by logout thunk clearing localStorage)
      .addCase(logout.fulfilled, (state) => {
        state.userInfo = null;
        state.loading = false;
        state.error = null;
      });
  },
});

// Export actions generated by createSlice
export const { userAuthRequest, userAuthSuccess, userAuthFail } = authSlice.actions;
// Note: userLogout action is now handled by the logout async thunk

// Export selectors
export const selectUser = (state) => state.auth.userInfo;

export default authSlice.reducer;
